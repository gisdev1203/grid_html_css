<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Openlayer Grid</title>

    <!-- Openlayers -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@latest/ol.css" />
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/ol@latest/dist/ol.js"></script>
    <script
        src="https://cdn.polyfill.io/v2/polyfill.min.js?features=requestAnimationFrame,Element.prototype.classList,URL,Object.assign"></script>
    <script src="https://unpkg.com/@turf/turf"></script>
    <!-- ol-ext -->
    <link rel="stylesheet" href="./dist/ol-ext.css" />
    <script type="text/javascript" src="./dist/ol-ext.js"></script>
    <!-- Pointer events polyfill for old browsers, see https://caniuse.com/#feat=pointer -->
    <script src="https://unpkg.com/elm-pep"></script>
</head>

<body style="width: 100%;height: 100%;">
    <!-- Map div -->
    <div id="map" style="width:100%; height:100vh; margin: 0px; padding: 0px;"></div>
    <div className="rectangle" style="display: grid; position: absolute; top: 80px; left: 20px;">
        <button onClick="handle()" id="handle">Activate Draw</button>
        <button onClick="handleButtonValid()" style="margin-top: 5px; "> Valide</button>
        <button onClick="handleButtonValidtest()" style="margin-top: 5px; "> test</button>
    </div>
    <div className="rectangle" style="display: grid; position: absolute; top: 30px; left: 500px;">
        <div>
            <span>Grid Size</span>
            <input type="number" style="text-align: center; margin-right: 5px;" id="myInput" value="10"
                onchange="onInputChange(this)" />
            <span>m</span>
        </div>
        <div style="margin-top: 2px;">
            <span style="margin-right: 5px;">Grid mode</span>
            <select id="select" value={selectedOption} onchange='handleSelectChange(this)'>
                <option value="TRAlign">Top->Right align</option>
                <option value="TLAlign">Top->Left align</option>
                <option selected value="BLAlign">Bottom->Left align</option>
                <option value="BRAlign">Bottom->Right align</option>

            </select>
        </div>
    </div>

    <script type="text/javascript">
        var drawActive = false;
        var drawFeature = null;
        var newDrawFeature = null;
        var rectangle = null;
        var rectCoordinates = null;
        var rectgridLayer = null;
        var extent = null;
        var interaction = null;
        var value = 10;
        var draw = null;
        var startangle = 0;
        var startRadius = 10;
        var d = [0, 0];
        var map_grid_anchor = 'down_left';


        const map = new ol.Map({
            target: 'map',
            layers: [
                new ol.layer.Tile({
                    source: new ol.source.OSM(),
                }),
            ],
            view: new ol.View({
                center: [726376.0586457778, 5865060.915527701],
                // center: [261720, 5951081],
                zoom: 18,
            }),
        });

        const source = new ol.source.Vector({ wrapX: false });

        const vector = new ol.layer.Vector({
            source,
            style: new ol.style.Style({
                fill: new ol.style.Fill({
                    color: 'rgba(255, 255, 255, 0.2)',
                }),
                stroke: new ol.style.Stroke({
                    color: '#ffcc33',
                    width: 2,
                }),
            }),
            name: 'RectLayer'
        });


        map.addLayer(vector);

        function buttonTextChange(flag = false) {
            drawActive = !drawActive;
            if (drawActive) {
                document.getElementById('handle').textContent = "Deactivat Draw";
            }
            else {
                document.getElementById('handle').textContent = "Activat Draw";
                map.removeInteraction(draw);
                draw = null;

            }
        }

        function handle() {
            // let draw;
            buttonTextChange(false);
            if (!drawActive) return;
            if (rectgridLayer) {
                map.removeLayer(rectgridLayer);
                rectgridLayer = null;
                vector.getSource().removeFeature(drawFeature);
                drawFeature = null;
            }

            if (interaction) {
                map.removeInteraction(interaction);
                interaction = null;
            }

            draw = new ol.interaction.Draw({
                source: source,
                type: 'Circle',
                geometryFunction: ol.interaction.Draw.createBox(),
            });

            map.addInteraction(draw);

            draw.on('drawend', (event) => {
                const feature = event.feature;
                const geometry = feature.getGeometry();
                const extent = geometry.getExtent();
                const width = extent[2] - extent[0];
                const height = extent[3] - extent[1];
                drawFeature = feature;
                if (width < 300 && height < 300) {
                    drawFeature = feature;
                    buttonTextChange(true);
                } else {
                    alert('Rectangle must be less than 300x300m');
                    vector.getSource().removeFeature(feature);
                    return;
                }

                interaction = new ol.interaction.Transform({
                    enableRotatedTransform: false,
                    addCondition: ol.events.condition.shiftKeyOnly,
                    hitTolerance: 2,
                    translateFeature: false,
                    scale: true,
                    rotate: true,
                    // keepAspectRatio: undefined,
                    translate: true,
                    keepRectangle: true,
                    stretch: true,
                    pointRadius: function (f) {
                        var radius = f.get('radius') || 10;
                        return [radius, radius];
                    }
                });
                map.addInteraction(interaction);
                if (!interaction instanceof ol.interaction.Transform) return;


                interaction.set('translate', interaction.get('translate'));
                interaction.on(['rotatestart', 'translatestart', 'scalestart'], function (e) {
                    startangle = e.feature.get('angle') || 0;
                    startRadius = e.feature.get('radius') || 10;
                    d = [0, 0];
                });
                interaction.on('rotating', function (e) {
                    e.feature.set('angle', startangle - e.angle);
                });
                interaction.on('translating', function (e) {
                    d[0] += e.delta[0];
                    d[1] += e.delta[1];
                });
                interaction.on('scaling', function (e) {
                    if (e.features.getLength() === 1) {
                        var feature = e.features.item(0);
                        feature.set('radius', startRadius * Math.abs(e.scale[0]));
                    }
                });

                interaction.on(['rotateend', 'translateend', 'scaleend'], function (e) {
                    console.log(e.features.getArray()[0]);
                    drawFeature = e.features.getArray()[0];
                });

                // Refresh
                interaction.set('translate', interaction.get('translate'));

            });
        };

        function getFeaturefromGeoJSON(map_grid_geo_json) {
            var format = new ol.format.GeoJSON();
            var feature = format.readFeature(map_grid_geo_json, {
                dataProjection: 'EPSG:3857',
                featureProjection: 'EPSG:3857',
            });
            const rectangleCoordinates = feature.getGeometry().getCoordinates()[0];
            const polygon = new ol.geom.Polygon([[
                rectangleCoordinates[1],
                rectangleCoordinates[2],
                rectangleCoordinates[3],
                rectangleCoordinates[0],
                rectangleCoordinates[1]
            ]]);
            return feature;

            // return new ol.Feature({
            //                 geometry: polygon,
            //             });
        }
        function getProjFeatureFromPoint(point) {
            const json = '{"type":"Feature", "properties":null,"geometry":{"type":"Point","coordinates":[' + point[0] + ',' + point[1] + ']' + '} }';
            var format = new ol.format.GeoJSON();
            var newfeature = format.readFeature(json, {
                dataProjection: 'EPSG:3857',
                featureProjection: 'EPSG:3857',
            });
            return newfeature;
        }

        function handleButtonValidtest() {
            // if (interaction) {
            //     map.removeInteraction(interaction);
            //     interaction = (null);
            // }
            //var map_grid_geo_json = '{"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[6.525147155,46.52609521599999],[6.524717199,46.52589173700002],[6.525159396,46.525446587000005],[6.525589356000001,46.525650067000015],[6.525147155,46.52609521599999]]]},"properties":null}';

            var map_grid_geo_json = '{"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[726302.0708929402, 5865129.018235411], [726384.8445342669, 5865094.198327251], [726398.894672647, 5865207.5157476645], [726306.3470220123, 5865208.126623247], [726302.0708929402, 5865129.018235411] ]]},"properties":null}';

            drawFeature = getFeaturefromGeoJSON(map_grid_geo_json);


            if (drawFeature) {
                const layers = map.getLayers();

                const gridStyle = new ol.style.Style({
                    image: new ol.style.Circle({
                        fill: new ol.style.Fill({
                            color: 'red',
                        }),
                        stroke: new ol.style.Stroke({
                            color: 'black',
                            width: 2,
                        }),
                        radius: 8,
                    }),
                    stroke: new ol.style.Stroke({
                        color: 'blue',
                        width: 2,
                    }),
                    text: new ol.style.Text({
                        fill: new ol.style.Fill({
                            color: 'rgba(255, 0, 0, 1)'
                        }),
                        font: '12px sans-serif',
                        textBaseline: 'bottom',
                        text: 'label'
                    })
                });

                const gridSource = new ol.source.Vector();
                const gridLayer = new ol.layer.Vector({
                    source: gridSource,
                    style: function (feature) {
                        const fill = new ol.style.Fill({
                            color: 'rgba(255, 0, 0, 0.2)'
                        });
                        const stroke = new ol.style.Stroke({
                            color: 'blue',
                            width: 2
                        });
                        const text = new ol.style.Text({
                            fill: new ol.style.Fill({
                                color: 'rgba(255, 0, 0, 1)'
                            }),
                            font: '12px sans-serif',
                            textBaseline: 'center',
                            text: feature.get('text')
                        });

                        return new ol.style.Style({
                            fill: fill,
                            stroke: stroke,
                            text: text,
                            image: new ol.style.Circle({
                                radius: 6,
                                fill: new ol.style.Fill({
                                    color: 'red'
                                }),
                                stroke: new ol.style.Stroke({
                                    color: 'black',
                                    width: 2
                                })
                            })
                        });
                    }
                });

                map.addLayer(gridLayer);
                rectgridLayer = (gridLayer);

                const extent = drawFeature.getGeometry().getExtent();
                const [minX, minY, maxX, maxY] = drawFeature.getGeometry().getExtent();

                const rectWidth = Math.abs(maxX - minX);
                const rectHeight = Math.abs(maxY - minY);
                const cellSize = value
                // const cellHeight1 = value
                const numCols = (rectWidth / value);
                const numRows = (rectHeight / value);

                getNewRectangleFromPolygon(drawFeature.getGeometry().getCoordinates()[0], gridSource);

                // gridSource.addFeature(pointFeature2);
                /*
                    (minX, maxY) ----------- > (maxX, maxY)
                         |                          |
                         |                          |
                         |                          |
                         |                          |    
                    (minX, minY) ---------- > (maxX, minY)
                */


                // gridSource.addFeature(new ol.Feature({
                //     geometry: new ol.geom.LineString([
                //         [minX, minY],
                //         [maxX, minY],
                //     ]),
                // }));
                // gridSource.addFeature(new ol.Feature({
                //     geometry: new ol.geom.LineString([
                //         [minX, minY],
                //         [minX, maxY],
                //     ]),
                // }));
                // gridSource.addFeature(new ol.Feature({
                //     geometry: new ol.geom.LineString([
                //         [maxX, maxY],
                //         [minX, maxY],
                //     ]),
                // }));
                // gridSource.addFeature(new ol.Feature({
                //     geometry: new ol.geom.LineString([
                //         [maxX, minY],
                //         [maxX, maxY],
                //     ]),
                // }));


                // for columns
                // for (let i = 1; i <= parseInt(numCols); i++) {

                //     const line = new ol.geom.LineString([
                //         [minX + cellSize * i, minY],
                //         [minX + cellSize * i, maxY],
                //     ]);

                //     const lineFeature = new ol.Feature({
                //         geometry: line,
                //     });

                //     const poly1 = turf.polygon(drawFeature.getGeometry().getCoordinates());
                //     const line1 = turf.lineString(lineFeature.getGeometry().getCoordinates());
                //     const intersection1 = turf.lineIntersect(poly1, line1);
                //     let points = [];
                //     if (intersection1) {

                //         turf.coordEach(intersection1, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
                //             points.push(currentCoord);
                //             // console.log('current', currentCoord);
                //         });

                //         const line = new ol.geom.LineString([
                //             points[0],
                //             points[1],
                //         ]);

                //         const lineFeature1 = new ol.Feature({
                //             geometry: line,
                //         });

                //         // gridSource.addFeature(lineFeature1);

                //         console.log("points", points);


                //     } else {
                //         console.log("No intersection found.");
                //     }
                // }

                // // for rows

                // for (let j = 1; j <= parseInt(numRows); j++) {
                //     const line = new ol.geom.LineString([
                //         [minX, minY + cellSize * j],
                //         [maxX, minY + cellSize * j],
                //     ]);

                //     const lineFeature = new ol.Feature({
                //         geometry: line,
                //     });

                //     const poly1 = turf.polygon(drawFeature.getGeometry().getCoordinates());
                //     const line1 = turf.lineString(lineFeature.getGeometry().getCoordinates());
                //     const intersection1 = turf.lineIntersect(poly1, line1);
                //     let points = [];
                //     if (intersection1) {

                //         turf.coordEach(intersection1, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
                //             points.push(currentCoord);
                //             // console.log('current', currentCoord);
                //         });

                //         const line = new ol.geom.LineString([
                //             points[0],
                //             points[1],
                //         ]);

                //         const lineFeature1 = new ol.Feature({
                //             geometry: line,
                //         });

                //         // gridSource.addFeature(lineFeature1);

                //         console.log("points", points);

                //     } else {
                //         console.log("No intersection found.");
                //     }
                // }

                // map.on('click', function (event) {
                //     const clickedCoordinates = event.coordinate;
                //     console.log(clickedCoordinates);
                //     if (!drawFeature) return;
                // });
            }
        };

        function isValidPoint(pt1, pt2, pt3) {
            var minX = pt1[0];
            var maxX = pt2[0];
            if (pt1[0] >= pt2[0]) {
                minX = pt2[0];
                maxX = pt1[0];
            }

            if (pt3[0] > minX && pt3[0] < maxX) return false;

            return true;
        }
        function getBaseLinePointsArray(array) {
            console.log("array", array);
            if (array.length == 2) return [array[0], array[0], array[1]];
            var newArray = [];

            var Vx = array[1][0] - array[0][0];
            var Vy = array[1][1] - array[0][1];

            if (array.length == 3) {
                var Vx1 = array[2][0] - array[0][0];
                var Vy1 = array[2][1] - array[0][1];
                if (Vx / Vy == Vx1 / Vy1) {
                    return [array[0], array[0], array[2]];
                } else {
                    return [array[0], array[2], array[1]];
                }
            } else if (array.length == 4) {
                var Vx1 = array[2][0] - array[0][0];
                var Vy1 = array[2][1] - array[0][1];
                var Vx2 = array[3][0] - array[0][0];
                var Vy2 = array[3][1] - array[0][1];
                if (Vx / Vy == Vx1 / Vy1 && Vx / Vy == Vx2 / Vy2) {
                    return [array[0], array[2], array[1]];
                } else if (Vx / Vy == Vx1 / Vy1) {
                    return [array[0], array[3], array[2]];
                } else if (Vx / Vy == Vx2 / Vy2) {
                    return [array[0], array[2], array[3]];
                } else {
                    console.log("other case");
                }
            }
            return [array[0], array[0], array[1]];
        }

        function getNewCoords(baseLinePointsArray, pt1, pt2) {
            var pointToLineDistance1 = getPointToLineDistance(baseLinePointsArray[1], baseLinePointsArray[2], pt1);
            var pointToLineDistance2 = getPointToLineDistance(baseLinePointsArray[1], baseLinePointsArray[2], pt2);
            var tempPoint = [0, 0];
            if (pointToLineDistance1 >= pointToLineDistance2) {
                tempPoint = pt1;
            } else {
                tempPoint = pt2;
            }
            var points = getAnotherPoints(baseLinePointsArray[1], baseLinePointsArray[2], tempPoint);
            return [baseLinePointsArray[1], baseLinePointsArray[2], points[0], points[1], baseLinePointsArray[1]];
        }


        function getPointToLineDistance(pt1, pt2, pt0) {

            var lineCoeff = getLineCoeff(pt1, pt2);
            var a = lineCoeff[0];
            var b = lineCoeff[1];

            var distance = Math.abs(a * pt0[0] - pt0[1] + b) / Math.sqrt(a * a + 1);
            return distance;
        }

        function getAnotherPoints(pt1, pt2, pt0) {

            var lineCoeff = getLineCoeff(pt1, pt2);
            var a = lineCoeff[0];
            var b = lineCoeff[1];

            var b1 = pt0[1] - a * pt0[0];
            var b2 = pt1[1] + pt1[0] / a;
            var x = (b2 - b1) / (a + 1 / a);
            var y = - x / a + b2;
            var b3 = pt2[1] + pt2[0] / a;
            var x1 = (b3 - b1) / (a + 1 / a);
            var y1 = - x1 / a + b3;
            return [[x1, y1], [x, y]];
        }

        function getLineCoeff(pt1, pt2) {
            let a = 1;
            if ((pt1[0] - pt2[0]) == 0) a = 1;
            else a = (pt1[1] - pt2[1]) / (pt1[0] - pt2[0]);
            let b = 0;
            b = pt1[1] - a * pt1[0];
            return [a, b]
        }


        // function getPointFromPerpendicularLine(pt1, pt2, pt0) {
        //     let lineCoeff = getLineCoeff(pt1, pt2);
        //     var b1 = pt0[1] + pt0[0] / lineCoeff;
        //     var x = (b1 - b) / (a + 1 / a);
        //     var y = - x / a + b1;
        //     return [x, y];
        // }

        function getClosestPointFromLine(pt1, pt2, pt0) {
            let lineCoeff = getLineCoeff(pt1, pt2);
            var b1 = pt0[1] + pt0[0] / lineCoeff[0];
            var x = (b1 - lineCoeff[1]) / (lineCoeff[0] + 1 / lineCoeff[0]);
            var y = - x / lineCoeff[0] + b1;
            return [x, y];
        }



        function getCoordsByLongerLine(coordinates) {
            var pointArray = [];
            if (map_grid_anchor == 'down_left') {
                pointArray.push(coordinates[0]);
                var length1 = getLength(coordinates[0], coordinates[1]);
                var length2 = getLength(coordinates[0], coordinates[3]);
                if (length1 >= length2) {
                    pointArray.push(coordinates[1]);
                    pointArray.push(coordinates[2]);
                    pointArray.push(coordinates[3]);
                } else {
                    pointArray.push(coordinates[3]);
                    pointArray.push(coordinates[2]);
                    pointArray.push(coordinates[1]);
                }
            } else if (map_grid_anchor == 'down_right') {
                pointArray.push(coordinates[1]);
                var length1 = getLength(coordinates[1], coordinates[0]);
                var length2 = getLength(coordinates[1], coordinates[2]);
                if (length1 >= length2) {
                    pointArray.push(coordinates[0]);
                    pointArray.push(coordinates[3]);
                    pointArray.push(coordinates[2]);
                } else {
                    pointArray.push(coordinates[2]);
                    pointArray.push(coordinates[3]);
                    pointArray.push(coordinates[0]);
                }
            } else if (map_grid_anchor == 'up_left') {
                pointArray.push(coordinates[3]);
                var length1 = getLength(coordinates[3], coordinates[0]);
                var length2 = getLength(coordinates[3], coordinates[2]);
                if (length1 >= length2) {
                    pointArray.push(coordinates[0]);
                    pointArray.push(coordinates[1]);
                    pointArray.push(coordinates[2]);
                } else {
                    pointArray.push(coordinates[2]);
                    pointArray.push(coordinates[1]);
                    pointArray.push(coordinates[0]);
                }
            } else if (map_grid_anchor == 'up_right') {
                pointArray.push(coordinates[2]);
                var length1 = getLength(coordinates[2], coordinates[3]);
                var length2 = getLength(coordinates[2], coordinates[1]);
                if (length1 >= length2) {
                    pointArray.push(coordinates[3]);
                    pointArray.push(coordinates[0]);
                    pointArray.push(coordinates[1]);
                } else {
                    pointArray.push(coordinates[1]);
                    pointArray.push(coordinates[0]);
                    pointArray.push(coordinates[3]);
                }
            }

            return pointArray;
        }


        function getNewRectangleFromPolygon(coordinates, source) {
            source.addFeature(drawFeature);

            var alignCoords = getCoordsByLongerLine(coordinates);
            console.log("alignCoords", alignCoords);
            var pointArray = [alignCoords[0], alignCoords[1]];
            var nearestPoint = getClosestPointFromLine(alignCoords[0], alignCoords[1], coordinates[2]);
            if (isValidPoint(alignCoords[0], alignCoords[1], nearestPoint))
                pointArray.push(nearestPoint);
            nearestPoint = getClosestPointFromLine(alignCoords[0], alignCoords[1], coordinates[3]);
            if (isValidPoint(alignCoords[0], alignCoords[1], nearestPoint))
                pointArray.push(nearestPoint);
            var baseLinePointsArray = getBaseLinePointsArray(pointArray);

            var newCoords = getNewCoords(baseLinePointsArray, alignCoords[2], alignCoords[3]);
            console.log("newCoords", newCoords);

            console.log(baseLinePointsArray);

            var newFeature = new ol.Feature({
                geometry: new ol.geom.LineString(
                    [baseLinePointsArray[1],
                    baseLinePointsArray[2],]
                ),
            });
            newFeature = new ol.Feature({
                geometry: new ol.geom.Point(
                    baseLinePointsArray[0]
                ),
            });
            source.addFeature(newFeature);

            newFeature = new ol.Feature({
                geometry: new ol.geom.Point(
                    baseLinePointsArray[1]
                ),
            });
            source.addFeature(newFeature);

            newFeature = new ol.Feature({
                geometry: new ol.geom.Point(
                    baseLinePointsArray[2]
                ),
            });
            source.addFeature(newFeature);

            newFeature = new ol.Feature({
                geometry: new ol.geom.Point(
                    newCoords[3]
                ),
            });
            source.addFeature(newFeature);

            // var newPolygon = getNewPolygon([baseLinePointsArray[1], baseLinePointsArray[2], points[0], points[1], pointArray[startPointIndex]], source);
            newFeature = new ol.Feature({
                geometry: new ol.geom.Polygon(
                    [newCoords]
                ),
            });
            source.addFeature(newFeature);


            return
            var pointIndex = getLongerPointIndex(coordinates);
            const pointCoord = coordinates[2];
            var pointArray = [];
            var nearestPoint = getClosestPointFromLine(coordinates[0], coordinates[pointIndex], coordinates[2]);

            pointArray.push(newPoint);
            newPoint = getClosestPointFromLine(coordinates[0], coordinates[pointIndex], coordinates[3]);
            pointArray.push(newPoint);
            pointArray.push(coordinates[0]);
            pointArray.push(coordinates[pointIndex]);


            var startPointIndex = 0;
            var endPointIndex = 1;
            var maxLength = 0;

            for (var i = 0; i < pointArray.length - 1; i++) {
                var start = pointArray[i];
                for (var j = i + 1; j < pointArray.length; j++) {
                    var end = pointArray[j];
                    var length = getLength(start, end);

                    if (length > maxLength) {
                        maxLength = length;
                        startPointIndex = i;
                        endPointIndex = j;
                    }
                }
            }

            var pointToLineDistance1 = getPointToLineDistance(pointArray[startPointIndex], pointArray[endPointIndex], coordinates[2]);
            var pointToLineDistance2 = getPointToLineDistance(pointArray[startPointIndex], pointArray[endPointIndex], coordinates[3]);
            var tempPoint = [0, 0];
            if (pointToLineDistance1 >= pointToLineDistance2) {
                tempPoint = coordinates[2];
            } else {
                tempPoint = coordinates[3];
            }

            var points = getAnotherPoints(pointArray[startPointIndex], pointArray[endPointIndex], tempPoint);
            var newFeature = new ol.Feature({
                geometry: new ol.geom.Polygon(
                    [[pointArray[startPointIndex], pointArray[endPointIndex], points[0], points[1], pointArray[startPointIndex]]]
                ),
            });

            source.addFeature(newFeature);
            var newPolygon = getNewPolygon([pointArray[startPointIndex], pointArray[endPointIndex], points[0], points[1], pointArray[startPointIndex]], source);
            newFeature = new ol.Feature({
                geometry: new ol.geom.Polygon(
                    [newPolygon]
                ),
            });
            source.addFeature(newFeature);



            const rectangleCoordinates = newFeature.getGeometry().getCoordinates()[0];
            const rectwidth = Math.abs(rectangleCoordinates[1][0] - rectangleCoordinates[0][0]);
            const rectheight = Math.abs(rectangleCoordinates[3][1] - rectangleCoordinates[0][1]);

            const numCols1 = (rectwidth / value);
            const numRows1 = (rectheight / value);

            const Ax = rectangleCoordinates[0][0] - rectangleCoordinates[1][0];
            const Ay = rectangleCoordinates[0][1] - rectangleCoordinates[1][1];
            const Bx = rectangleCoordinates[0][0] - rectangleCoordinates[3][0];
            const By = rectangleCoordinates[0][1] - rectangleCoordinates[3][1];

            const ta = value * 1.0 / (Math.sqrt(Ax * Ax + Ay * Ay));
            const tb = value * 1.0 / (Math.sqrt(Bx * Bx + By * By));

            for (let i = 1; i <= parseInt(numCols1); i++) {
                if (map_grid_anchor === 'BLAlign') {

                    const line = new ol.geom.LineString([
                        [rectangleCoordinates[0][0] - ta * Ax * i, rectangleCoordinates[0][1] - ta * Ay * i],
                        [rectangleCoordinates[3][0] - ta * Ax * i, rectangleCoordinates[3][1] - ta * Ay * i],
                        // Add as many points as necessary
                    ]);

                    const lineFeature = new ol.Feature({
                        geometry: line,
                    });
                    // gridSource.addFeature(lineFeature);

                    const poly1 = turf.polygon(drawFeature.getGeometry().getCoordinates());
                    const line1 = turf.lineString(lineFeature.getGeometry().getCoordinates());
                    const intersection1 = turf.lineIntersect(poly1, line1);

                    let pointsTurf = [];
                    if (intersection1) {

                        turf.coordEach(intersection1, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
                            pointsTurf.push(currentCoord);
                        });
                        if (pointsTurf.length < 2) continue;

                        //     source.addFeature(new ol.Feature({
                        //     geometry: new ol.geom.Point(pointsTurf[0]),
                        // }));

                        const line = new ol.geom.LineString([
                            pointsTurf[0],
                            pointsTurf[1],
                        ]);

                        const lineFeature1 = new ol.Feature({
                            geometry: line,
                        });

                        source.addFeature(lineFeature1);

                    } else {
                        console.log("No intersection found.");
                    }
                }
                else if (map_grid_anchor === 'BRAlign') {
                    const line = new ol.geom.LineString([
                        [rectangleCoordinates[1][0] - cellWidth1 * i, rectangleCoordinates[1][1] + cellHeight_temp * i],
                        [rectangleCoordinates[2][0] - cellWidth1 * i, rectangleCoordinates[2][1] + cellHeight_temp * i],
                        // Add as many points as necessary
                    ]);
                    const lineFeature = new ol.Feature({
                        geometry: line,
                    });
                    gridSource.addFeature(lineFeature);
                }
                else if (map_grid_anchor === 'TLAlign') {
                    const line = new ol.geom.LineString([
                        [rectangleCoordinates[0][0] + cellWidth1 * i, rectangleCoordinates[0][1] - cellHeight_temp * i],
                        [rectangleCoordinates[3][0] + cellWidth1 * i, rectangleCoordinates[3][1] - cellHeight_temp * i],
                        // Add as many points as necessary
                    ]);

                    const lineFeature = new ol.Feature({
                        geometry: line,
                    });
                    gridSource.addFeature(lineFeature);
                } else if (map_grid_anchor === 'TRAlign') {
                    const line = new ol.geom.LineString([
                        [rectangleCoordinates[1][0] - cellWidth1 * i, rectangleCoordinates[1][1] + cellHeight_temp * i],
                        [rectangleCoordinates[2][0] - cellWidth1 * i, rectangleCoordinates[2][1] + cellHeight_temp * i],
                        // Add as many points as necessary
                    ]);
                    const lineFeature = new ol.Feature({
                        geometry: line,
                    });
                    gridSource.addFeature(lineFeature);
                }
            }

            for (let j = 1; j <= parseInt(numRows1); j++) {

                if (map_grid_anchor === 'BLAlign' || map_grid_anchor === 'BRAlign') {

                    const line = new ol.geom.LineString([
                        [rectangleCoordinates[0][0] - tb * Bx * j, rectangleCoordinates[0][1] - tb * By * j],
                        [rectangleCoordinates[1][0] - tb * Bx * j, rectangleCoordinates[1][1] - tb * By * j],
                        // Add as many points as necessary
                    ]);

                    const lineFeature = new ol.Feature({
                        geometry: line,
                    });
                    // gridSource.addFeature(lineFeature);
                    const poly1 = turf.polygon(drawFeature.getGeometry().getCoordinates());
                    const line1 = turf.lineString(lineFeature.getGeometry().getCoordinates());
                    const intersection1 = turf.lineIntersect(poly1, line1);
                    let pointsTurf = [];
                    if (intersection1) {

                        turf.coordEach(intersection1, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
                            pointsTurf.push(currentCoord);
                        });
                        if (pointsTurf.length < 2) continue;
                        const line = new ol.geom.LineString([
                            pointsTurf[0],
                            pointsTurf[1],
                        ]);

                        const lineFeature1 = new ol.Feature({
                            geometry: line,
                        });

                        source.addFeature(lineFeature1);

                    } else {
                        console.log("No intersection found.");
                    }
                }
                else if (map_grid_anchor === 'TLAlign' || map_grid_anchor === 'TRAlign') {

                    const line = new ol.geom.LineString([
                        [rectangleCoordinates[3][0] + cellWidth_temp * j, rectangleCoordinates[3][1] - cellHeight1 * j],
                        [rectangleCoordinates[2][0] + cellWidth_temp * j, rectangleCoordinates[2][1] - cellHeight1 * j],
                        // Add as many points as necessary
                    ]);

                    const lineFeature = new ol.Feature({
                        geometry: line,
                    });

                    gridSource.addFeature(lineFeature);
                }
            }

            newDrawFeature = newFeature;

            map.on('click', function (event) {
                const clickedCoordinates = event.coordinate;
                console.log(clickedCoordinates);

                if (!newDrawFeature) return;
                const rectangleCoordinates = newDrawFeature.getGeometry().getCoordinates()[0];
                const rectwidth = rectangleCoordinates[1][0] - rectangleCoordinates[0][0];
                const rectheight = rectangleCoordinates[3][1] - rectangleCoordinates[0][1];

                const cellWidth_temp = (rectangleCoordinates[1][1] - rectangleCoordinates[0][1]) / numCols1;
                const cellHeight_temp = (rectangleCoordinates[3][0] - rectangleCoordinates[0][0]) / numRows1;
                const Ax = rectangleCoordinates[0][0] - rectangleCoordinates[1][0];
                const Ay = rectangleCoordinates[0][1] - rectangleCoordinates[1][1];
                const Bx = rectangleCoordinates[0][0] - rectangleCoordinates[3][0];
                const By = rectangleCoordinates[0][1] - rectangleCoordinates[3][1];

                const ta = value * 1.0 / (Math.sqrt(Ax * Ax + Ay * Ay));
                const tb = value * 1.0 / (Math.sqrt(Bx * Bx + By * By));

                for (let i = 0; i <= Math.ceil(numCols1); i++) {
                    for (let j = 0; j <= Math.ceil(numRows1); j++) {

                        if (map_grid_anchor == 'BLAlign') {

                            // Calculate the coordinates of the current grid cell
                            let cellTopLeft = [
                                rectangleCoordinates[0][0] - tb * Bx * j - ta * Ax * (i - 1),
                                rectangleCoordinates[0][1] - tb * By * j - ta * Ay * (i - 1)
                            ];

                            let cellBottomRight = [
                                rectangleCoordinates[0][0] - tb * Bx * (j - 1) - ta * Ax * i,
                                rectangleCoordinates[0][1] - tb * By * (j - 1) - ta * Ay * i
                            ];

                            let cellTopRight = [
                                rectangleCoordinates[0][0] - tb * Bx * (j) - ta * Ax * i,
                                rectangleCoordinates[0][1] - tb * By * (j) - ta * Ay * i

                            ];

                            // // Draw a new rectangle with the top-left corner of the grid cell as the starting point
                            let cellBottomLeft = [
                                rectangleCoordinates[0][0] - tb * Bx * (j - 1) - ta * Ax * (i - 1),
                                rectangleCoordinates[0][1] - tb * By * (j - 1) - ta * Ay * (i - 1)
                            ];


                            let tempolygon = new ol.geom.Polygon(
                                [
                                    [
                                        cellBottomLeft,
                                        cellBottomRight,
                                        cellTopRight,
                                        cellTopLeft,
                                        cellBottomLeft
                                    ]
                                ]
                            );

                            let isInside = tempolygon.intersectsCoordinate(clickedCoordinates);

                            if (isInside) {
                                const newFeature = new ol.Feature({
                                    geometry: new ol.geom.Polygon(
                                        [[
                                            cellBottomLeft,
                                            cellBottomRight,
                                            cellTopRight,
                                            cellTopLeft,
                                            cellBottomLeft
                                        ]]
                                    ),
                                });

                                const poly1 = turf.polygon(drawFeature.getGeometry().getCoordinates());
                                const cellPolygon = turf.polygon(newFeature.getGeometry().getCoordinates());

                                const intersection1 = turf.intersect(cellPolygon, poly1);
                                if (intersection1) {
                                    var coords = turf.getCoords(intersection1);
                                    tempolygon = new ol.geom.Polygon(coords);
                                    source.addFeature(new ol.Feature({
                                        geometry: tempolygon,
                                    }));
                                } else {
                                    console.log("no intersection")
                                }
                                break
                            }
                        }
                        if (map_grid_anchor == 'BRAlign') {
                            let cellTopLeft = [
                                rectangleCoordinates[1][0] - cellWidth_temp * (j) - cellWidth1 * (i),
                                rectangleCoordinates[1][1] + cellHeight1 * (j) + cellHeight_temp * (i)
                            ];
                            let cellTopRight = [
                                rectangleCoordinates[1][0] - cellWidth_temp * (j) - cellWidth1 * (i - 1),
                                rectangleCoordinates[1][1] + cellHeight1 * (j) + cellHeight_temp * (i - 1)
                            ];
                            let cellBottomRight = [
                                rectangleCoordinates[1][0] - cellWidth_temp * (j - 1) - cellWidth1 * (i - 1),
                                rectangleCoordinates[1][1] + cellHeight1 * (j - 1) + cellHeight_temp * (i - 1)
                            ];
                            let cellBottomLeft = [
                                rectangleCoordinates[1][0] - cellWidth_temp * (j - 1) - cellWidth1 * (i),
                                rectangleCoordinates[1][1] + cellHeight1 * (j - 1) + cellHeight_temp * (i)
                            ];

                            if (i !== Math.ceil(numCols1) && j === Math.ceil(numRows1)) {
                                cellTopLeft = [rectangleCoordinates[2][0] - cellWidth1 * (i), rectangleCoordinates[2][1] + cellHeight_temp * (i)];
                                cellTopRight = [rectangleCoordinates[2][0] - cellWidth1 * (i - 1), rectangleCoordinates[2][1] + cellHeight_temp * (i - 1)];
                            }

                            if (i === Math.ceil(numCols1) && j !== Math.ceil(numRows1)) {
                                cellTopLeft = [rectangleCoordinates[0][0] - cellWidth_temp * j, rectangleCoordinates[0][1] + cellHeight1 * j];
                                cellBottomLeft = [rectangleCoordinates[0][0] - cellWidth_temp * (j - 1), rectangleCoordinates[0][1] + cellHeight1 * (j - 1)];
                            }

                            if (i === Math.ceil(numCols1) && j === Math.ceil(numRows1)) {
                                cellTopLeft = [rectangleCoordinates[3][0], rectangleCoordinates[3][1]];
                                cellTopRight = [rectangleCoordinates[2][0] - cellWidth1 * (i - 1), rectangleCoordinates[2][1] + cellHeight_temp * (i - 1)];
                                cellBottomLeft = [rectangleCoordinates[0][0] - cellWidth_temp * (j - 1), rectangleCoordinates[0][1] + cellHeight1 * (j - 1)];
                            }

                            const tempolygon = new ol.geom.Polygon(
                                [
                                    [
                                        cellBottomLeft,
                                        cellTopLeft,
                                        cellTopRight,
                                        cellBottomRight,
                                        cellBottomLeft
                                    ]
                                ]
                            );

                            // Check if the point is inside the rotated rectangle
                            var isInside = tempolygon.intersectsCoordinate(clickedCoordinates);

                            // Check if the clicked coordinates fall within the current grid cell
                            if (isInside) {
                                const cellIndex = (i - 1) * parseInt(numRows1) + parseInt(j);

                                const cellRectangle = new ol.Feature(
                                    {
                                        geometry: new ol.geom.Polygon([
                                            [
                                                cellBottomLeft,
                                                cellTopLeft,
                                                cellTopRight,
                                                cellBottomRight,
                                                cellBottomLeft
                                            ]
                                        ]),
                                        text: cellIndex.toString(),
                                    }
                                );


                                gridSource.addFeature(cellRectangle);

                                // The clicked point is within this grid cell
                                console.log('Clicked on cell:', i, j);
                                console.log('Clicked on cell:', (i - 1) * numCols1 + j);
                                break;
                            }
                        }
                        else if (option === 'TLAlign') {
                            let cellTopLeft = [rectangleCoordinates[3][0] + cellWidth_temp * (j - 1) + cellWidth1 * (i - 1), rectangleCoordinates[3][1] - cellHeight1 * (j - 1) - cellHeight_temp * (i - 1)];
                            let cellBottomRight = [rectangleCoordinates[3][0] + cellWidth_temp * j + cellWidth1 * i, rectangleCoordinates[3][1] - cellHeight1 * j - cellHeight_temp * i];
                            let cellBottomLeft = [
                                rectangleCoordinates[3][0] + cellWidth_temp * (j) + cellWidth1 * (i - 1),
                                rectangleCoordinates[3][1] - cellHeight1 * (j) - cellHeight_temp * (i - 1)
                            ];

                            let cellTopRight = [
                                rectangleCoordinates[3][0] + cellWidth_temp * (j - 1) + cellWidth1 * (i),
                                rectangleCoordinates[3][1] - cellHeight1 * (j - 1) - cellHeight_temp * (i)
                            ];

                            if (i !== Math.ceil(numCols1) && j === Math.ceil(numRows1)) {
                                cellBottomRight = [rectangleCoordinates[0][0] + cellWidth1 * (i), rectangleCoordinates[0][1] - cellHeight_temp * (i)];
                                cellBottomLeft = [rectangleCoordinates[0][0] + cellWidth1 * (i - 1), rectangleCoordinates[0][1] - cellHeight_temp * (i - 1)];
                            }

                            if (i === Math.ceil(numCols1) && j !== Math.ceil(numRows1)) {
                                cellTopRight = [rectangleCoordinates[2][0] + cellWidth_temp * (j - 1), rectangleCoordinates[2][1] - cellHeight1 * (j - 1)];
                                cellBottomRight = [rectangleCoordinates[2][0] + cellWidth_temp * (j), rectangleCoordinates[2][1] - cellHeight1 * (j)];

                            }

                            if (i === Math.ceil(numCols1) && j === Math.ceil(numRows1)) {
                                cellBottomRight = [rectangleCoordinates[1][0], rectangleCoordinates[1][1]];
                                cellBottomLeft = [rectangleCoordinates[0][0] + cellWidth1 * (i - 1), rectangleCoordinates[0][1] - cellHeight_temp * (i - 1)];
                                cellTopRight = [rectangleCoordinates[2][0] + cellWidth_temp * (j - 1), rectangleCoordinates[2][1] - cellHeight1 * (j - 1)];
                            }

                            const tempolygon = new ol.geom.Polygon([
                                [
                                    cellTopLeft,
                                    cellTopRight,
                                    cellBottomRight,
                                    cellBottomLeft,
                                    cellTopLeft
                                ]
                            ]);
                            // Check if the point is inside the rotated rectangle
                            var isInside = tempolygon.intersectsCoordinate(clickedCoordinates);
                            if (isInside) {
                                const cellIndex = (i - 1) * parseInt(numRows1) + parseInt(j);
                                const cellRectangle = new ol.Feature({
                                    geometry: new ol.geom.Polygon([
                                        [
                                            cellTopLeft,
                                            cellTopRight,
                                            cellBottomRight,
                                            cellBottomLeft,
                                            cellTopLeft
                                        ]
                                    ]),
                                    text: cellIndex.toString(),
                                });
                                gridSource.addFeature(cellRectangle);
                                break;
                            }
                        }
                        else if (option === 'TRAlign') {
                            let cellTopLeft = [
                                rectangleCoordinates[2][0] + cellWidth_temp * (j - 1) - cellWidth1 * (i),
                                rectangleCoordinates[2][1] - cellHeight1 * (j - 1) + cellHeight_temp * (i)
                            ];
                            let cellTopRight = [
                                rectangleCoordinates[2][0] + cellWidth_temp * (j - 1) - cellWidth1 * (i - 1),
                                rectangleCoordinates[2][1] - cellHeight1 * (j - 1) + cellHeight_temp * (i - 1)
                            ];
                            let cellBottomRight = [
                                rectangleCoordinates[2][0] + cellWidth_temp * (j) - cellWidth1 * (i - 1),
                                rectangleCoordinates[2][1] - cellHeight1 * (j) + cellHeight_temp * (i - 1)
                            ];
                            let cellBottomLeft = [
                                rectangleCoordinates[2][0] + cellWidth_temp * (j) - cellWidth1 * (i),
                                rectangleCoordinates[2][1] - cellHeight1 * (j) + cellHeight_temp * (i)
                            ];

                            if (i !== Math.ceil(numCols1) && j === Math.ceil(numRows1)) {
                                cellBottomRight = [rectangleCoordinates[1][0] - cellWidth1 * (i - 1), rectangleCoordinates[1][1] + cellHeight_temp * (i - 1)];
                                cellBottomLeft = [rectangleCoordinates[1][0] - cellWidth1 * (i), rectangleCoordinates[1][1] + cellHeight_temp * (i)];
                            }

                            if (i === Math.ceil(numCols1) && j !== Math.ceil(numRows1)) {
                                cellTopLeft = [rectangleCoordinates[3][0] + cellWidth_temp * (j - 1), rectangleCoordinates[3][1] - cellHeight1 * (j - 1)];
                                cellBottomLeft = [rectangleCoordinates[3][0] + cellWidth_temp * (j), rectangleCoordinates[3][1] - cellHeight1 * (j)];

                            }

                            if (i === Math.ceil(numCols1) && j === Math.ceil(numRows1)) {

                                cellTopLeft = [rectangleCoordinates[3][0] + cellWidth_temp * (j - 1), rectangleCoordinates[3][1] - cellHeight1 * (j - 1)];

                                cellBottomRight = [rectangleCoordinates[1][0] - cellWidth1 * (i - 1), rectangleCoordinates[1][1] + cellHeight_temp * (i - 1)];

                                cellBottomLeft = [rectangleCoordinates[0][0], rectangleCoordinates[0][1]];
                            }

                            const tempolygon = new ol.geom.Polygon(
                                [
                                    [
                                        cellBottomLeft,
                                        cellTopLeft,
                                        cellTopRight,
                                        cellBottomRight,
                                        cellBottomLeft
                                    ]
                                ]
                            );
                            // Check if the point is inside the rotated rectangle
                            var isInside = tempolygon.intersectsCoordinate(clickedCoordinates);
                            if (isInside) {
                                const cellIndex = (i - 1) * parseInt(numRows1) + parseInt(j);
                                const cellRectangle = new ol.Feature({
                                    geometry: new ol.geom.Polygon([
                                        [
                                            cellBottomLeft,
                                            cellTopLeft,
                                            cellTopRight,
                                            cellBottomRight,
                                            cellBottomLeft
                                        ]
                                    ]),
                                    text: cellIndex.toString(),
                                });
                                gridSource.addFeature(cellRectangle);
                                break;
                            }
                        }
                    }
                }
            });


        }

        function getNewPolygon(pointArray, source) {

            var newFeature = new ol.Feature({
                geometry: new ol.geom.Polygon(
                    [[pointArray[0], pointArray[1], pointArray[2], pointArray[3], pointArray[0]]]
                ),
            });

            source.addFeature(newFeature);

            const Ax = pointArray[0][0] - pointArray[1][0];
            const Ay = pointArray[0][1] - pointArray[1][1];
            const Bx = pointArray[0][0] - pointArray[3][0];
            const By = pointArray[0][1] - pointArray[3][1];

            const ta = value * 1.0 / (Math.sqrt(Ax * Ax + Ay * Ay));
            const tb = value * 1.0 / (Math.sqrt(Bx * Bx + By * By));



            const newPoint1 = getNewPoint([Ax, Ay], [Bx, By], ta, tb, pointArray[0]);
            const newPoint2 = getNewPoint([-Ax, -Ay], [Bx, By], ta, tb, pointArray[1]);
            const newPoint3 = getNewPoint([-Ax, -Ay], [-Bx, -By], ta, tb, pointArray[2]);
            const newPoint4 = getNewPoint([Ax, Ay], [-Bx, -By], ta, tb, pointArray[3]);

            newFeature = new ol.Feature({
                geometry: new ol.geom.Point(
                    newPoint1
                ),
            });
            source.addFeature(newFeature);

            newFeature = new ol.Feature({
                geometry: new ol.geom.Point(
                    newPoint2
                ),
            });
            source.addFeature(newFeature);
            newFeature = new ol.Feature({
                geometry: new ol.geom.Point(
                    newPoint3
                ),
            });
            source.addFeature(newFeature);
            newFeature = new ol.Feature({
                geometry: new ol.geom.Point(
                    newPoint4
                ),
            });
            source.addFeature(newFeature);
            return [newPoint1, newPoint2, newPoint3, newPoint4, newPoint1];
        }

        function getNewPoint(VectorA, VectorB, ta, tb, pt) {
            const newX1 = ta * VectorA[0] + pt[0];
            const newY1 = ta * VectorA[1] + pt[1];
            const newX2 = tb * VectorB[0] + pt[0];
            const newY2 = tb * VectorB[1] + pt[1];
            const X = newX1 + newX2 - pt[0];
            const Y = newY1 + newY2 - pt[1];
            return [X, Y];
        }

        function getLength(point1, point2) {
            return Math.sqrt((point2[0] - point1[0]) * (point2[0] - point1[0]) + (point2[1] - point1[1]) * (point2[1] - point1[1]));
        }


        function onInputChange(e) {
            value = e.value;
        }

        function handleSelectChange(e) {
            map_grid_anchor = e.value;
        }

    </script>
</body>

</html>